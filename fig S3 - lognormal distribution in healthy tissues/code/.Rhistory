summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = NULL)
head(mini_tma@cell_metadata$rna$slide)
tissue_feat_type
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = NULL,
tissue_column, tissue_feat_type = "rna",
count_feat_type = 'rna', count_expression_values = 'raw',
neg_feat_type = 'negprobes', neg_expression_values = 'raw')
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = NULL,
tissue_feat_type = "rna",
count_feat_type = 'rna', count_expression_values = 'raw',
neg_feat_type = 'negprobes', neg_expression_values = 'raw')
object = mini_tma
tissue_column = "slide"
fake_feat_type = NULL
fake_expression_values = NULL
# extract data matrices or else store as NULL if not available:
neg <- NULL
if (!is.null(neg_expression_values)) {
neg <- object@expression[[neg_feat_type]][[neg_expression_values]]
}
fake <- NULL
count_feat_type = 'rna'
count_expression_values = 'raw'
neg_feat_type = 'negprobes'
neg_expression_values = 'raw'
# extract data matrices or else store as NULL if not available:
neg <- NULL
if (!is.null(neg_expression_values)) {
neg <- object@expression[[neg_feat_type]][[neg_expression_values]]
}
fake <- NULL
if (!is.null(fake_expression_values)) {
fake <- object@expression[[fake_feat_type]][[fake_expression_values]]
}
fake
str(object@cell_metadata[[tissue_feat_type]][[tissue_column]])
tissue_feat_type = "rna"
str(object@cell_metadata[[tissue_feat_type]][[tissue_column]])
# call QC_stats_from_tissues, which operates on base objects:
out <- QC_stats_from_tissues(
counts = object@expression[[count_feat_type]][[count_expression_values]],
neg = neg,
fake = fake,
tissue = object@cell_metadata[[tissue_feat_type]][[tissue_column]],
cell_removed = rep(FALSE, length(tissue)))
counts = object@expression[[count_feat_type]][[count_expression_values]]
tissue = object@cell_metadata[[tissue_feat_type]][[tissue_column]]
cell_removed = rep(FALSE, length(tissue))
# summarize cells per tissue:
n.cells.analyzed <- table(tissue[!cell_removed])
if (sum(cell_removed) > 0) {
n.cells.removed <- table(tissue[cell_removed])
}
# summarize counts:
totcounts <- Matrix::colSums(counts)
counts.per.cell.mean <- round(by(totcounts, INDICES = tissue, FUN = mean), 0.1)
counts.per.cell.q1 <- round(by(totcounts, INDICES = tissue, FUN = quantile, 0.1), 0.1)
counts.per.cell.q9 <- round(by(totcounts, INDICES = tissue, FUN = quantile, 0.9), 0.1)
# summarize negprobes:
if (!is.null(neg)) {
totneg <- Matrix::colSums(neg)
neg.per.cell.mean <- round(by(totneg, INDICES = tissue, FUN = mean), 0.1)
}
# summarize falecodes:
if (!is.null(fake)) {
totfake <- Matrix::colSums(fake)
fake.per.cell.mean <- round(by(totfake, INDICES = tissue, FUN = mean), 0.1)
}
# combine all stats:
stats <- c("n.cells.analyzed", "n.cells.removed",
"counts.per.cell.mean", "counts.per.cell.q1", "counts.per.cell.q9",
"neg.per.cell.mean", "fake.per.cell.mean")
out = data.frame(tissue = unique(tissue))
for (stat in stats) {
if (exists(stat)) {
out[[stat]] <- get(stat)[out$tissue]
}
}
out
# call QC_stats_from_tissues, which operates on base objects:
out <- QC_stats_from_tissues(
counts = object@expression[[count_feat_type]][[count_expression_values]],
neg = neg,
fake = fake,
tissue = object@cell_metadata[[tissue_feat_type]][[tissue_column]],
cell_removed = rep(FALSE, length(tissue)))
rm(tissue)
# call QC_stats_from_tissues, which operates on base objects:
out <- QC_stats_from_tissues(
counts = object@expression[[count_feat_type]][[count_expression_values]],
neg = neg,
fake = fake,
tissue = object@cell_metadata[[tissue_feat_type]][[tissue_column]],
cell_removed = rep(FALSE, length(tissue)))
tissue = rep("all", length(object@cell_ID))
tissue
if (!is.null(tissue_column)) {
tissue <- object@cell_metadata[[tissue_feat_type]][[tissue_column]]
}
tussue
tissue
source('~/Ptolemy/R/summarizeSMIPerformance.R', echo=TRUE)
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = NULL)
is.element(object@cell_ID, flagged_cell_ids)
flagged_cell_ids = NULL
is.element(object@cell_ID, flagged_cell_ids)
source('~/Ptolemy/R/summarizeSMIPerformance.R', echo=TRUE)
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = NULL)
head(mini_tma@cell_ID)
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = c("1_4446" ,"1_4448"))
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = NULL,
flagged_cell_ids = c("1_4446" ,"1_4448"))
source('~/Ptolemy/R/summarizeSMIPerformance.R', echo=TRUE)
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = c("1_4446" ,"1_4448"))
summarizeSMIPerformance(mini_tma, tissue_column = "slide",
fake_feat_type = NULL, fake_expression_values = NULL,
flagged_cell_ids = c("1_4446" ,"1_4448"))
library(devtools)
install("C:\\Users\\pdanaher\\Desktop\\Gemini-interactive-visualizer-main\\Gemini-interactive-visualizer-main")
library(installr)
updateR()
library(Ptolemy)
?plotCells
?scale_color_viridis
1.5 * 1000000 / 5000
1.5 * 200000 / 5000
load("C:/Users/pdanaher/Box Sync/Gemini/Evan Newell collaboration/4114 - Evan Newell 1000plex/Evan 1000plex giotto object.RData")
ls()
str(gem@expression)
str(gem)
gem@dimension_reduction
load("C:/Users/pdanaher/Box Sync/Gemini/Evan Newell collaboration/4114 - Evan Newell 1000plex/Evan 1000plex UMAP.RData")
ls()
str(um)
umapcoords = um$layout
load("C:/Users/pdanaher/Box Sync/Gemini/Evan Newell collaboration/4114 - Evan Newell 1000plex/4114 semi-supervised results - evan reference profiles.RData")
ls()
str(ensemi)
head(ensemi$clust)
table(ensemi$clust)
rm(ensemi)
load("C:/Users/pdanaher/Box Sync/Gemini/Evan Newell collaboration/4114 - Evan Newell 1000plex/4114 semi-supervised results - evan reference profiles.RData")
head(gem@spatial_locs)
plot(gem@spatial_locs[,1:2], col = colors()[as.numeric(as.factor(ensemi$clust))])
plot(gem@spatial_locs[,1:2], col = colors()[as.numeric(as.factor(ensemi$clust))], cex = 0.3, pch = 16)
celltype = ensemi$clust
celltyps[celltype == "Cluster A"] = "i"
celltype[celltype == "Cluster A"] = "i"
celltype[celltype == "Cluster B"] = "i"
table(celltype)
save(celltype, umapcoords, file = "cell clusters and umap coordinates.RData")
head(pDataDT(gem))
pDataDT(gem)$cluster = celltype
gem@cell_metadata$rna$cluster = celltype
gem@cell_metadata$rna$umap1 = umapcoords[,1]
gem@cell_metadata$rna$umap2 = umapcoords[,2]
save(gem, file = "Evan Newell data with clusters and umap coords.RData")
getwd()
rn(list = ls())
rm(list = ls())
load("C:/Users/pdanaher/Box Sync/Gemini/Evan Newell collaboration/4114 - Evan Newell 1000plex/Evan Newell data with clusters and umap coords.RData")
ls()
head(pDataDT(gem))
dim(gem@expression$rna$norm)
#str(gem@parameters$`6_delaunay_spatial_network`)
# see this:
head(gem@spatial_network$Delaunay_network$networkDT)
source('~/.active-rstudio-document')
library(Ptolemy) # Load library
data(mini_tma) # Load data
mini_tma <- runPCA(mini_tma, expression_values="raw", ncp = 5) # Run PCA
X <- Giotto:::select_dimReduction(mini_tma, name = "pca") # Use PCA results as expression matrix
dim(X)
N <- 100 # Select the desired sample size
sampledCells <- geoSketch(X, N) # Generate list of sampled cells
um = umap(t(as.matrix(mini_tma@expression$rna$raw)))
library(umap)
um = umap(t(as.matrix(mini_tma@expression$rna$raw)))
plot(um$layout, col = 1 + is.element(mini_tma@cell_ID, sampledCells))
plot(um$layout, col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
head(X)
dim(X)
um = umap(X)
plot(um$layout, col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
sampledCells
points(um$layout[sampledCells, ], col = "red", pch = 16)
sampledCells <- geoSketch(um$layout, N) # Generate list of sampled cells
plot(um$layout, col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
points(um$layout[sampledCells, ], col = "red", pch = 16)
sampledCells <- geoSketch(X, N) # Generate list of sampled cells
plot(X[, 1:2], col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
points(X[sampledCells, 1:2], col = "red", pch = 16)
sampledCells <- geoSketch(X, N = 1000) # Generate list of sampled cells
plot(um$layout, col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
points(um$layout[sampledCells, ], col = "red", pch = 16)
geoSketchRes <- geoSketch(X, N, returnBins=TRUE) # Generate list of sampled cells and return named vector of binIDs used for sampling
geoSketchRes
str(geoSketchRes)
table(geoSketchRes$binIDs)
head(geoSketchRes$binIDs)
geoSketchRes <- geoSketch(um$layout, N, returnBins=TRUE) # Generate list of sampled cells and return named vector of binIDs used for sampling
table(geoSketchRes$binIDs)
plot(X[, 3:4], col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
points(X[sampledCells, 3:4], col = "red", pch = 16)
sampledCells <- geoSketch(X, N = 100) # Generate list of sampled cells
plot(X[, 3:4], col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
points(X[sampledCells, 3:4], col = "red", pch = 16)
plot(um$layout, col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16)
points(um$layout[sampledCells, ], col = "red", pch = 16)
pairs(X[, 1:2], col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16, cex = 0.5)
pairs(X, col = 1 + is.element(mini_tma@cell_ID, sampledCells), pch = 16, cex = 0.5 + is.element(mini_tma@cell_ID, sampledCells))
sampledCells
sampledCells.u <- geoSketch(um$layout, N) # Generate list of sampled cells
plot(um$layout, col = 1 + is.element(mini_tma@cell_ID, sampledCells.u), pch = 16)
points(um$layout[sampledCells.u, ], col = "red", pch = 16)
index
library(Giotto)
?Giotto::createNearestNetwork
data(mini_giotto_single_cell)
mini_giotto_single_cell <- createNearestNetwork(gobject = mini_giotto_single_cell,
dimensions_to_use = 1:3, k = 3)
#' Estimate platform effects / gene scaling factors
#'
#' Estimates a scaling factor for each gene to bring the fixed_profiles onto the scale of the data.
#'  Models the log ratio between platforms as a function of gene, cell line, and
#'  reference expression.
#' @param mean_profiles Matrix of mean background-subtracted expression of genes * clusters.
#' @param fixed_profiles Matrix of pre-specified reference profiles.
#' @return A vector of scaling factors used to multiply the rows of fixed_profiles
estimate_platform_effects <- function(mean_profiles, fixed_profiles) {
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
## find columns of mean_profiles with insufficient info, and remove:
# flag all-0 columns:
all_zero_columns <- colnames(mean_profiles)[colSums(mean_profiles) == 0]
# flag columns with too few non-zero values:
prop_nonzero <- colMeans(mean_profiles > 0)
poor_data_columns <- colnames(mean_profiles)[prop_nonzero < 0.1 * mean(prop_nonzero)]
# remove:
df <- df[!is.element(df$cell, c(all_zero_columns, poor_data_columns)), ]
# remove rows where ref == 0:
df <- df[df$ref > 0, ]
# lower-threshold the observed means so 0 values don't go to -Inf:
df$obs <- pmax(df$obs, quantile(df$obs[df$obs>0], 0.01))
# calc logratio
df$logratio <- log(df$obs / df$ref)
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
coefs <- mod$coefficients[grepl("gene", names(mod$coefficients))]
# add coefs for genes that got dropped due to all 0s in df:
names(coefs) <- gsub("gene", "", names(coefs))
lostgenes <- setdiff(rownames(mean_profiles), names(coefs))
coefs[lostgenes] <- mean(coefs)
coefs <- coefs[rownames(mean_profiles)]
return(exp(coefs))
}
estimate_platform_effects(mean_profiles = ioprofiles, fixed_profiles)
library(Ptolemy)
data("ioprofiles")
estimate_platform_effects(mean_profiles = ioprofiles, fixed_profiles = ioprofiles)
dim(ioprofiles)
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5])
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500))
ioprofiles[1:100, 1:5]
ioprofiles[1:100, 1:5]+rnorm(500)
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500))
mean_profiles = ioprofiles[1:100, 1:5]
ioprofiles[1:100, 1:5] + rnorm(500)
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500)
mean_profiles = ioprofiles[1:100, 1:5]
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
## find columns of mean_profiles with insufficient info, and remove:
# flag all-0 columns:
all_zero_columns <- colnames(mean_profiles)[colSums(mean_profiles) == 0]
# flag columns with too few non-zero values:
prop_nonzero <- colMeans(mean_profiles > 0)
poor_data_columns <- colnames(mean_profiles)[prop_nonzero < 0.1 * mean(prop_nonzero)]
# remove:
df <- df[!is.element(df$cell, c(all_zero_columns, poor_data_columns)), ]
head(df)
str(df)
# remove rows where ref == 0:
df <- df[df$ref > 0, ]
# lower-threshold the observed means so 0 values don't go to -Inf:
df$obs <- pmax(df$obs, quantile(df$obs[df$obs>0], 0.01))
# calc logratio
df$logratio <- log(df$obs / df$ref)
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
range(df$ref)
sum(is.na(df))
mod <- lm(logratio ~ 0 + gene + cell, data = df)
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
range(log(df$ref))
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(df$ref))
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
hist(df$ref)
hist(log(df$ref))
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref) - min(log(ref)))
#' Estimate platform effects / gene scaling factors
#'
#' Estimates a scaling factor for each gene to bring the fixed_profiles onto the scale of the data.
#'  Models the log ratio between platforms as a function of gene, cell line, and
#'  reference expression.
#' @param mean_profiles Matrix of mean background-subtracted expression of genes * clusters.
#' @param fixed_profiles Matrix of pre-specified reference profiles.
#' @return A vector of scaling factors used to multiply the rows of fixed_profiles
estimate_platform_effects <- function(mean_profiles, fixed_profiles) {
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
## find columns of mean_profiles with insufficient info, and remove:
# flag all-0 columns:
all_zero_columns <- colnames(mean_profiles)[colSums(mean_profiles) == 0]
# flag columns with too few non-zero values:
prop_nonzero <- colMeans(mean_profiles > 0)
poor_data_columns <- colnames(mean_profiles)[prop_nonzero < 0.1 * mean(prop_nonzero)]
# remove:
df <- df[!is.element(df$cell, c(all_zero_columns, poor_data_columns)), ]
# remove rows where ref == 0:
df <- df[df$ref > 0, ]
# lower-threshold the observed means so 0 values don't go to -Inf:
df$obs <- pmax(df$obs, quantile(df$obs[df$obs>0], 0.01))
# calc logratio
df$logratio <- log(df$obs / df$ref)
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref) - min(log(ref)))
coefs <- mod$coefficients[grepl("gene", names(mod$coefficients))]
# add coefs for genes that got dropped due to all 0s in df:
names(coefs) <- gsub("gene", "", names(coefs))
lostgenes <- setdiff(rownames(mean_profiles), names(coefs))
coefs[lostgenes] <- mean(coefs)
coefs <- coefs[rownames(mean_profiles)]
return(exp(coefs))
}
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500))
library(seurat)
install.packages("seurat")
install.packages("Seurat")
library(seurat)
library(SpatialDecon)
# get mouse brain visium data:
InstallData("stxBrain")
library(Seurat)
# get mouse brain visium data:
InstallData("stxBrain")
library(SeuratData)
# get mouse brain visium data:
InstallData("stxBrain")
brain <- LoadData("stxBrain", type = "anterior1")
str(barin)
str(brain)
# download Allen mouse brain profiles:
load(url("https://github.com/Nanostring-Biostats/CellProfileLibrary/raw/NewProfileMatrices/Mouse/Adult/Brain_AllenBrainAtlas.RData"))
head(profile_matrix)
ls()
print(cellGroups)
print(cellGroups)
raw <- as.matrix(SeuratObject::GetAssayData(object, assay = "Spatial"))
raw <- as.matrix(SeuratObject::GetAssayData(brain, assay = "Spatial"))
str(raw)
head(profile_matrix)
?spatialdecon
View(spatialdecon())
View(spatialdecon)
View(algorithm2)
# run spatialdecon:
res <- spatialdecon(norm = raw, raw = raw, bg = 0.01,
X = profile_matrix, align_genes = TRUE, cellmerges = cellGroups)
raw <- as.matrix(SeuratObject::GetAssayData(brain, assay = "Spatial"))
dim(raw)
str(profile_matrix)
# run spatialdecon:
res <- spatialdecon(norm = raw, raw = raw, bg = 0.01,
X = as.matrix(profile_matrix), align_genes = TRUE, cellmerges = cellGroups)
str(res)
con <- gzcon(url("https://github.com/almaan/her2st/blob/master/data/ST-cnts/G1.tsv.gz"))
txt <- readLines(con)
temp <- read.table(textConnection(txt), sep = "\t")
dim(temp)
head(temp)
temp
load("C:/Users/pdanaher/Box Sync/Gemini/4089 - CPA 16 cell lines/Run4098_CPA_dataset.RData")
max(GemiObj@expression$rna$raw)
library(Giotto)
max(GemiObj@expression$rna$raw)
max(GemiObj@expression$raw)
ls()
max(GemiObj@expression)
max(GemiObj@expression_feat)
load("C:/Users/pdanaher/Box Sync/Gemini/vizgen mouse showcase/complete vizgene showcase data - counts and metadata.RData")
ls()
dim(raw)
min(rowSums(raw))
mean(rowSums(raw))
str(gem)
library(devtools)
devtools::install_github("Nanostring-Biostats/SpatialDecon",
ref = "resivions-for-journal",
build_vignettes = FALSE)
?install_github
devtools::install_github("Nanostring-Biostats/SpatialDecon",
ref = "master",
build_vignettes = FALSE)
devtools::install_github("Nanostring-Biostats/SpatialDecon",
ref = "revisions-for-journal",
build_vignettes = FALSE)
BiocManager::install("SpatialDecon")
sessionInfo()
>BiocManager::install
?BiocManager::install
BiocManager::version()
BiocManager::install("SpatialDecon", version = "3.10")
BiocManager::install("SpatialDecon", version = "3.11")
BiocManager::install("SpatialDecon", version = "3.12")
BiocManager::version()
sessionInfo()
library(SpatialDecon)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(SpatialDecon)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(SpatialDecon)
data("mini_geomx_dataset")
norm = mini_geomx_dataset$normalized
raw = mini_geomx_dataset$raw
annot = mini_geomx_dataset$annot
dim(raw)
head(annot)
raw[seq_len(5), seq_len(5)]
# better segment names:
colnames(norm) = colnames(raw) = rownames(annot) =
paste0(annot$ROI, annot$AOI.name)
# use the NegProbe to estimate per-observation background
per.observation.mean.neg = norm["NegProbe", ]
# and define a background matrix in which each column (observation) is the
# appropriate value of per-observation background:
bg = sweep(norm * 0, 2, per.observation.mean.neg, "+")
dim(bg)
bg2 = derive_GeoMx_background(norm = norm,
probepool = rep(1, nrow(norm)),
negnames = "NegProbe")
# vector identifying pure tumor segments:
annot$istumor = (annot$AOI.name == "Tumor")
# run spatialdecon with all the bells and whistles:
restils = spatialdecon(norm = norm,                     # normalized data
raw = raw,                       # raw data, used to down-weight low-count observations
bg = bg,                         # expected background counts for every data point in norm
X = safeTME,                     # safeTME matrix, used by default
cellmerges = safeTME.matches,   # safeTME.matches object, used by default
cell_counts = annot$nuclei,      # nuclei counts, used to estimate total cells
is_pure_tumor = annot$istumor,   # identities of the Tumor segments/observations
n_tumor_clusters = 5)            # how many distinct tumor profiles to append to safeTME
str(restils)
getwd()
sd(rep(0,100),100)
sd(c(rep(0,100),100))
sd(c(rep(0,100),1000))
mean(c(rep(0,100),1000))
mean(c(rep(0,1000000),1000000))
sd(c(rep(0,1000000),1000000))
source("~/SpatialDecon-manuscript-analyses/fig S3new - lognormal distribution in healthy tissues/code/evaluate lognormal distribution in kidney.R")
setwd("~/SpatialDecon-manuscript-analyses/fig S3new - lognormal distribution in healthy tissues/code")
source("~/SpatialDecon-manuscript-analyses/fig S3new - lognormal distribution in healthy tissues/code/evaluate lognormal distribution in pancreas.R")
source("~/SpatialDecon-manuscript-analyses/fig S3new - lognormal distribution in healthy tissues/code/evaluate lognormal distribution in kidney.R")
getwd()
dir()
source("~/SpatialDecon-manuscript-analyses/fig S3new - lognormal distribution in healthy tissues/code/evaluate lognormal distribution in kidney.R")
source("~/SpatialDecon-manuscript-analyses/fig S3new - lognormal distribution in healthy tissues/code/evaluate lognormal distribution in pancreas.R")
source("~/SpatialDecon-manuscript-analyses/fig S3new - lognormal distribution in healthy tissues/code/evaluate lognormal distribution in pancreas.R")
