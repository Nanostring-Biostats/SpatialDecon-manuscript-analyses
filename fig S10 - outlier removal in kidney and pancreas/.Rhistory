#' Estimates a scaling factor for each gene to bring the fixed_profiles onto the scale of the data.
#'  Models the log ratio between platforms as a function of gene, cell line, and
#'  reference expression.
#' @param mean_profiles Matrix of mean background-subtracted expression of genes * clusters.
#' @param fixed_profiles Matrix of pre-specified reference profiles.
#' @return A vector of scaling factors used to multiply the rows of fixed_profiles
estimate_platform_effects <- function(mean_profiles, fixed_profiles) {
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
## find columns of mean_profiles with insufficient info, and remove:
# flag all-0 columns:
all_zero_columns <- colnames(mean_profiles)[colSums(mean_profiles) == 0]
# flag columns with too few non-zero values:
prop_nonzero <- colMeans(mean_profiles > 0)
poor_data_columns <- colnames(mean_profiles)[prop_nonzero < 0.1 * mean(prop_nonzero)]
# remove:
df <- df[!is.element(df$cell, c(all_zero_columns, poor_data_columns)), ]
# remove rows where ref == 0:
df <- df[df$ref > 0, ]
# lower-threshold the observed means so 0 values don't go to -Inf:
df$obs <- pmax(df$obs, quantile(df$obs[df$obs>0], 0.01))
# calc logratio
df$logratio <- log(df$obs / df$ref)
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
coefs <- mod$coefficients[grepl("gene", names(mod$coefficients))]
# add coefs for genes that got dropped due to all 0s in df:
names(coefs) <- gsub("gene", "", names(coefs))
lostgenes <- setdiff(rownames(mean_profiles), names(coefs))
coefs[lostgenes] <- mean(coefs)
coefs <- coefs[rownames(mean_profiles)]
return(exp(coefs))
}
estimate_platform_effects(mean_profiles = ioprofiles, fixed_profiles)
library(Ptolemy)
data("ioprofiles")
estimate_platform_effects(mean_profiles = ioprofiles, fixed_profiles = ioprofiles)
dim(ioprofiles)
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5])
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500))
ioprofiles[1:100, 1:5]
ioprofiles[1:100, 1:5]+rnorm(500)
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500))
mean_profiles = ioprofiles[1:100, 1:5]
ioprofiles[1:100, 1:5] + rnorm(500)
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500)
mean_profiles = ioprofiles[1:100, 1:5]
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
## find columns of mean_profiles with insufficient info, and remove:
# flag all-0 columns:
all_zero_columns <- colnames(mean_profiles)[colSums(mean_profiles) == 0]
# flag columns with too few non-zero values:
prop_nonzero <- colMeans(mean_profiles > 0)
poor_data_columns <- colnames(mean_profiles)[prop_nonzero < 0.1 * mean(prop_nonzero)]
# remove:
df <- df[!is.element(df$cell, c(all_zero_columns, poor_data_columns)), ]
head(df)
str(df)
# remove rows where ref == 0:
df <- df[df$ref > 0, ]
# lower-threshold the observed means so 0 values don't go to -Inf:
df$obs <- pmax(df$obs, quantile(df$obs[df$obs>0], 0.01))
# calc logratio
df$logratio <- log(df$obs / df$ref)
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
range(df$ref)
sum(is.na(df))
mod <- lm(logratio ~ 0 + gene + cell, data = df)
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
range(log(df$ref))
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(df$ref))
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref))
hist(df$ref)
hist(log(df$ref))
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref) - min(log(ref)))
#' Estimate platform effects / gene scaling factors
#'
#' Estimates a scaling factor for each gene to bring the fixed_profiles onto the scale of the data.
#'  Models the log ratio between platforms as a function of gene, cell line, and
#'  reference expression.
#' @param mean_profiles Matrix of mean background-subtracted expression of genes * clusters.
#' @param fixed_profiles Matrix of pre-specified reference profiles.
#' @return A vector of scaling factors used to multiply the rows of fixed_profiles
estimate_platform_effects <- function(mean_profiles, fixed_profiles) {
if(!identical(dim(mean_profiles), dim(fixed_profiles))){
stop("Please ensure the dimensions of mean_profiles and fixed_profiles are the same.")
}
# make data frame for model:
df <- data.frame(obs = as.vector(mean_profiles),
ref = as.vector(fixed_profiles),
gene = rep(rownames(mean_profiles), ncol(mean_profiles)),
cell = rep(colnames(mean_profiles), each = nrow(mean_profiles)))
## find columns of mean_profiles with insufficient info, and remove:
# flag all-0 columns:
all_zero_columns <- colnames(mean_profiles)[colSums(mean_profiles) == 0]
# flag columns with too few non-zero values:
prop_nonzero <- colMeans(mean_profiles > 0)
poor_data_columns <- colnames(mean_profiles)[prop_nonzero < 0.1 * mean(prop_nonzero)]
# remove:
df <- df[!is.element(df$cell, c(all_zero_columns, poor_data_columns)), ]
# remove rows where ref == 0:
df <- df[df$ref > 0, ]
# lower-threshold the observed means so 0 values don't go to -Inf:
df$obs <- pmax(df$obs, quantile(df$obs[df$obs>0], 0.01))
# calc logratio
df$logratio <- log(df$obs / df$ref)
# fit the model:
mod <- lm(logratio ~ 0 + gene + cell, data = df, weights = log(ref) - min(log(ref)))
coefs <- mod$coefficients[grepl("gene", names(mod$coefficients))]
# add coefs for genes that got dropped due to all 0s in df:
names(coefs) <- gsub("gene", "", names(coefs))
lostgenes <- setdiff(rownames(mean_profiles), names(coefs))
coefs[lostgenes] <- mean(coefs)
coefs <- coefs[rownames(mean_profiles)]
return(exp(coefs))
}
estimate_platform_effects(mean_profiles = ioprofiles[1:100, 1:5], fixed_profiles = ioprofiles[1:100, 1:5] + rnorm(500))
library(seurat)
install.packages("seurat")
install.packages("Seurat")
library(seurat)
library(SpatialDecon)
# get mouse brain visium data:
InstallData("stxBrain")
library(Seurat)
# get mouse brain visium data:
InstallData("stxBrain")
library(SeuratData)
# get mouse brain visium data:
InstallData("stxBrain")
brain <- LoadData("stxBrain", type = "anterior1")
str(barin)
str(brain)
# download Allen mouse brain profiles:
load(url("https://github.com/Nanostring-Biostats/CellProfileLibrary/raw/NewProfileMatrices/Mouse/Adult/Brain_AllenBrainAtlas.RData"))
head(profile_matrix)
ls()
print(cellGroups)
print(cellGroups)
raw <- as.matrix(SeuratObject::GetAssayData(object, assay = "Spatial"))
raw <- as.matrix(SeuratObject::GetAssayData(brain, assay = "Spatial"))
str(raw)
head(profile_matrix)
?spatialdecon
View(spatialdecon())
View(spatialdecon)
View(algorithm2)
# run spatialdecon:
res <- spatialdecon(norm = raw, raw = raw, bg = 0.01,
X = profile_matrix, align_genes = TRUE, cellmerges = cellGroups)
raw <- as.matrix(SeuratObject::GetAssayData(brain, assay = "Spatial"))
dim(raw)
str(profile_matrix)
# run spatialdecon:
res <- spatialdecon(norm = raw, raw = raw, bg = 0.01,
X = as.matrix(profile_matrix), align_genes = TRUE, cellmerges = cellGroups)
str(res)
con <- gzcon(url("https://github.com/almaan/her2st/blob/master/data/ST-cnts/G1.tsv.gz"))
txt <- readLines(con)
temp <- read.table(textConnection(txt), sep = "\t")
dim(temp)
head(temp)
temp
load("C:/Users/pdanaher/Box Sync/Gemini/4089 - CPA 16 cell lines/Run4098_CPA_dataset.RData")
max(GemiObj@expression$rna$raw)
library(Giotto)
max(GemiObj@expression$rna$raw)
max(GemiObj@expression$raw)
ls()
max(GemiObj@expression)
max(GemiObj@expression_feat)
load("C:/Users/pdanaher/Box Sync/Gemini/vizgen mouse showcase/complete vizgene showcase data - counts and metadata.RData")
ls()
dim(raw)
min(rowSums(raw))
mean(rowSums(raw))
str(gem)
library(devtools)
devtools::install_github("Nanostring-Biostats/SpatialDecon",
ref = "resivions-for-journal",
build_vignettes = FALSE)
?install_github
devtools::install_github("Nanostring-Biostats/SpatialDecon",
ref = "master",
build_vignettes = FALSE)
devtools::install_github("Nanostring-Biostats/SpatialDecon",
ref = "revisions-for-journal",
build_vignettes = FALSE)
BiocManager::install("SpatialDecon")
sessionInfo()
>BiocManager::install
?BiocManager::install
BiocManager::version()
BiocManager::install("SpatialDecon", version = "3.10")
BiocManager::install("SpatialDecon", version = "3.11")
BiocManager::install("SpatialDecon", version = "3.12")
BiocManager::version()
sessionInfo()
library(SpatialDecon)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(SpatialDecon)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(SpatialDecon)
data("mini_geomx_dataset")
norm = mini_geomx_dataset$normalized
raw = mini_geomx_dataset$raw
annot = mini_geomx_dataset$annot
dim(raw)
head(annot)
raw[seq_len(5), seq_len(5)]
# better segment names:
colnames(norm) = colnames(raw) = rownames(annot) =
paste0(annot$ROI, annot$AOI.name)
# use the NegProbe to estimate per-observation background
per.observation.mean.neg = norm["NegProbe", ]
# and define a background matrix in which each column (observation) is the
# appropriate value of per-observation background:
bg = sweep(norm * 0, 2, per.observation.mean.neg, "+")
dim(bg)
bg2 = derive_GeoMx_background(norm = norm,
probepool = rep(1, nrow(norm)),
negnames = "NegProbe")
# vector identifying pure tumor segments:
annot$istumor = (annot$AOI.name == "Tumor")
# run spatialdecon with all the bells and whistles:
restils = spatialdecon(norm = norm,                     # normalized data
raw = raw,                       # raw data, used to down-weight low-count observations
bg = bg,                         # expected background counts for every data point in norm
X = safeTME,                     # safeTME matrix, used by default
cellmerges = safeTME.matches,   # safeTME.matches object, used by default
cell_counts = annot$nuclei,      # nuclei counts, used to estimate total cells
is_pure_tumor = annot$istumor,   # identities of the Tumor segments/observations
n_tumor_clusters = 5)            # how many distinct tumor profiles to append to safeTME
str(restils)
getwd()
setwd("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas")
source("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas/study outlier removal in pancreas.R")
cors = data.frame("no" = diag(cor(t(res_truth$beta), t(res_no$beta))),
"yes" = diag(cor(t(res_truth$beta), t(res_yes$beta))))
mses = data.frame("no" = rowMeans((res_truth$beta - res_no$beta)^2),
"yes" = rowMeans((res_truth$beta - res_yes$beta)^2))
par(mfrow = c(1,2))
par(mar = c(5,6,2,1))
plot(rowMeans(res_truth$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
lines(lowess(cors$no ~ rowMeans(res_truth$beta)[rownames(cors)]))
lines(lowess(cors$yes ~ rowMeans(res_truth$beta)[rownames(cors)]), col = 2)
legend("bottomright", pch = 16, col = c(1,2), legend = c("Outliers retained", "Outliers removed"), cex = 0.8)
plot(rowMeans(res_truth$beta), mses$no, pch = 16, ylim = c(0, max(mses)),
ylab = "Mean Squared Error between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta), mses$yes, col = 2, pch = 16)
lines(lowess(mses$no ~ rowMeans(res_truth$beta)))
lines(lowess(mses$yes ~ rowMeans(res_truth$beta)), col = 2)
setwd("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas")
rm(list = ls())
library(scales)
library(SpatialDecon)
annot = as.data.frame(read_xlsx("data/colon.xlsx", sheet = "SegmentProperties"))
raw0 = read_xlsx("data/colon.xlsx", sheet = "TargetCountMatrix")
raw = as.matrix(raw0[, -1])
rownames(raw) = raw0$TargetName
rm(raw0)
# normalize:
norm = sweep(raw, 2, apply(raw, 2, quantile, 0.9), "/") *  mean(apply(raw, 2, quantile, 0.9))
refmat = read.csv("data/colon_profileMatrix.csv", row.names = 1)
str(refmat)
refmat = as.matrix(read.csv("data/colon_profileMatrix.csv", row.names = 1))
str(refmat)
# normalize:
norm = sweep(raw, 2, apply(raw, 2, quantile, 0.9), "/") *  mean(apply(raw, 2, quantile, 0.9))
refmat = as.matrix(read.csv("data/colon_profileMatrix.csv", row.names = 1))
sharedgenes = intersect(rownames(refmat), rownames(norm))
# save original normalized data then perturb norm:
norm0 = norm
# add noise to a subset of genes:
set.seed(0)
to.perturb = sample(sharedgenes, 1000, replace = F)
perturbation = matrix((rnorm(length(norm[to.perturb, ]), mean = 0, sd = 3)), length(to.perturb))
norm[to.perturb, ] = norm[to.perturb, ] * 2 ^ perturbation
res_truth = spatialdecon(norm = norm0[sharedgenes, ],
raw = raw[sharedgenes, ],
bg = sweep(norm0*0, 2, norm["NegProbe-WTX", ], "+"),
X = refmat[sharedgenes, ],
resid_thresh = Inf)  # no outlier removal
#### run decon on perturbed dataset with and without outlier removal: ------------------------
# with outlier removal:
res_yes = spatialdecon(norm = norm[sharedgenes, ],
raw = raw[sharedgenes, ],
bg = sweep(norm*0, 2, norm["NegProbe-WTX", ], "+"),
X = refmat[sharedgenes, ],
resid_thresh = 3)   # default value for outlier removal
# without:
res_no = spatialdecon(norm = norm[sharedgenes, ],
raw = raw[sharedgenes, ],
bg = sweep(norm*0, 2, norm["NegProbe-WTX", ], "+"),
X = refmat[sharedgenes, ],
resid_thresh = Inf)  # no outlier removal
save(res_truth, res_no, res_yes, file = "results/decon results - colon.RData")
# simplest:
flagged = 1 * is.na(res_yes$resids)
nflagged = rowMeans(flagged[sharedgenes, ])
boxplot(nflagged ~ is.element(sharedgenes, to.perturb), ylab = "Proportion of regions where gene is flagged",
xlab = "", names = c("Unperturbed\n(14975 genes)", "Added noise\n(1000 genes)"), cex.lab = 1.5, outline = F)
points(1 + jitter(as.numeric(is.element(sharedgenes, to.perturb))), nflagged, pch = 16, col = alpha("darkblue", 0.7))
cors = data.frame("no" = diag(cor(t(res_truth$beta), t(res_no$beta))),
"yes" = diag(cor(t(res_truth$beta), t(res_yes$beta))))
mses = data.frame("no" = rowMeans((res_truth$beta - res_no$beta)^2),
"yes" = rowMeans((res_truth$beta - res_yes$beta)^2))
par(mfrow = c(1,2))
par(mar = c(5,6,2,1))
plot(rowMeans(res_truth$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
lines(lowess(cors$no ~ rowMeans(res_truth$beta)[rownames(cors)]))
lines(lowess(cors$yes ~ rowMeans(res_truth$beta)[rownames(cors)]), col = 2)
legend("bottomright", pch = 16, col = c(1,2), legend = c("Outliers retained", "Outliers removed"), cex = 0.8)
plot(rowMeans(res_truth$beta), mses$no, pch = 16, ylim = c(0, max(mses)),
ylab = "Mean Squared Error between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta), mses$yes, col = 2, pch = 16)
lines(lowess(mses$no ~ rowMeans(res_truth$beta)))
lines(lowess(mses$yes ~ rowMeans(res_truth$beta)), col = 2)
source("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas/study outlier removal in colon.R")
source("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas/study outlier removal in colon.R")
setwd("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas")
source("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas/study outlier removal in colon.R")
boxplot(nflagged ~ is.element(sharedgenes, to.perturb), ylab = "Proportion of regions where gene is flagged",
xlab = "", names = c("Unperturbed\n(14975 genes)", "Added noise\n(1000 genes)"), cex.lab = 1.5, outline = F)
points(1 + jitter(as.numeric(is.element(sharedgenes, to.perturb))), nflagged, pch = 16, col = alpha("darkblue", 0.7))
dim(notm)
dim(norm)
setwd("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas")
rm(list = ls())
library(scales)
library(SpatialDecon)
library(readxl)
#### load data --------------------------------
annot = as.data.frame(read_xlsx("data/pancreas Q3 Norm.xlsx", sheet = "SegmentProperties"))
raw0 = read_xlsx("data/pancreas Q3 Norm.xlsx", sheet = "TargetCountMatrix")
raw = as.matrix(raw0[, -1])
rownames(raw) = raw0$TargetName
rm(raw0)
# normalize:
norm = sweep(raw, 2, apply(raw, 2, quantile, 0.9), "/") *  mean(apply(raw, 2, quantile, 0.9))
#### get pancreas profile matrix: -------------------------------
refmat = download_profile_matrix(species = "Human", age_group = "Adult", matrixname = "Pancreas_HCA")
sharedgenes = intersect(rownames(refmat), rownames(norm))
#### perturb the data: ---------------------------------------------
# save original normalized data then perturb norm:
norm0 = norm
# add noise to a subset of genes:
set.seed(0)
to.perturb = sample(sharedgenes, 1000, replace = F)
perturbation = matrix((rnorm(length(norm[to.perturb, ]), mean = 0, sd = 3)), length(to.perturb))
norm[to.perturb, ] = norm[to.perturb, ] * 2 ^ perturbation
#### run decon with no outlier removal on normalized data --------------------------------
res_truth_no = spatialdecon(norm = norm0[sharedgenes, ],
raw = raw[sharedgenes, ],
bg = sweep(norm0*0, 2, norm["NegProbe-WTX", ], "+"),
X = refmat[sharedgenes, ],
resid_thresh = Inf)  # no outlier removal
res_truth_yes = spatialdecon(norm = norm0[sharedgenes, ],
raw = raw[sharedgenes, ],
bg = sweep(norm0*0, 2, norm["NegProbe-WTX", ], "+"),
X = refmat[sharedgenes, ],
resid_thresh = 3)  # default outlier removal
# with outlier removal:
res_yes = spatialdecon(norm = norm[sharedgenes, ],
raw = raw[sharedgenes, ],
bg = sweep(norm*0, 2, norm["NegProbe-WTX", ], "+"),
X = refmat[sharedgenes, ],
resid_thresh = 3)   # default value for outlier removal
# without:
res_no = spatialdecon(norm = norm[sharedgenes, ],
raw = raw[sharedgenes, ],
bg = sweep(norm*0, 2, norm["NegProbe-WTX", ], "+"),
X = refmat[sharedgenes, ],
resid_thresh = Inf)  # no outlier removal
save(res_truth_yes, res_truth_no, res_no, res_yes, file = "results/decon results - pancreas.RData")
cors = data.frame("no" = diag(cor(t(res_truth_no$beta), t(res_no$beta))),
"yes" = diag(cor(t(res_truth_yes$beta), t(res_yes$beta))))
mses = data.frame("no" = rowMeans((res_truth_no$beta - res_no$beta)^2),
"yes" = rowMeans((res_truth_yes$beta - res_yes$beta)^2))
par(mfrow = c(1,2))
par(mar = c(5,6,2,1))
plot(rowMeans(res_truth$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
lines(lowess(cors$no ~ rowMeans(res_truth$beta)[rownames(cors)]))
lines(lowess(cors$yes ~ rowMeans(res_truth$beta)[rownames(cors)]), col = 2)
legend("bottomright", pch = 16, col = c(1,2), legend = c("Outliers retained", "Outliers removed"), cex = 0.8)
plot(rowMeans(res_truth$beta), mses$no, pch = 16, ylim = c(0, max(mses)),
ylab = "Mean Squared Error between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta), mses$yes, col = 2, pch = 16)
lines(lowess(mses$no ~ rowMeans(res_truth$beta)))
lines(lowess(mses$yes ~ rowMeans(res_truth$beta)), col = 2)
save(res_truth_yes, res_truth_no, res_no, res_yes, file = "results/decon results - kidney.RData")
# simplest:
flagged = 1 * is.na(res_yes$resids)
nflagged = rowMeans(flagged[sharedgenes, ])
cors = data.frame("no" = diag(cor(t(res_truth$beta), t(res_no$beta))),
"yes" = diag(cor(t(res_truth$beta), t(res_yes$beta))))
mses = data.frame("no" = rowMeans((res_truth$beta - res_no$beta)^2),
"yes" = rowMeans((res_truth$beta - res_yes$beta)^2))
cors = data.frame("no" = diag(cor(t(res_truth_no$beta), t(res_no$beta))),
"yes" = diag(cor(t(res_truth_yes$beta), t(res_yes$beta))))
mses = data.frame("no" = rowMeans((res_truth_no$beta - res_no$beta)^2),
"yes" = rowMeans((res_truth_yes$beta - res_yes$beta)^2))
par(mfrow = c(1,2))
par(mar = c(5,6,2,1))
plot(rowMeans(res_truth$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
lines(lowess(cors$no ~ rowMeans(res_truth$beta)[rownames(cors)]))
lines(lowess(cors$yes ~ rowMeans(res_truth$beta)[rownames(cors)]), col = 2)
legend("bottomright", pch = 16, col = c(1,2), legend = c("Outliers retained", "Outliers removed"), cex = 0.8)
plot(rowMeans(res_truth$beta), mses$no, pch = 16,
ylab = "Mean Squared Error between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth$beta), mses$yes, col = 2, pch = 16)
lines(lowess(mses$no ~ rowMeans(res_truth$beta)))
lines(lowess(mses$yes ~ rowMeans(res_truth$beta)), col = 2)
par(mfrow = c(1,2))
par(mfrow = c(1,2))
par(mar = c(5,6,2,1))
plot(rowMeans(res_truth_no$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth_yes$beta - res_yes$beta$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
points(rowMeans(res_truth_yes$beta - res_yes$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
cors
mses
plot(rowMeans(res_truth_no$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth_yes$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
lines(lowess(cors$no ~ rowMeans(res_truth_no$beta)[rownames(cors)]))
lines(lowess(cors$yes ~ rowMeans(res_truth_yes$beta)[rownames(cors)]), col = 2)
legend("bottomright", pch = 16, col = c(1,2), legend = c("Outliers retained", "Outliers removed"), cex = 0.8)
par(mfrow = c(1,2))
par(mar = c(5,6,2,1))
plot(rowMeans(res_truth_no$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth_yes$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
lines(lowess(cors$no ~ rowMeans(res_truth_no$beta)[rownames(cors)]))
lines(lowess(cors$yes ~ rowMeans(res_truth_yes$beta)[rownames(cors)]), col = 2)
legend("bottomright", pch = 16, col = c(1,2), legend = c("Outliers retained", "Outliers removed"), cex = 0.8)
plot(rowMeans(res_truth_no$beta), mses$no, pch = 16,
ylab = "Mean Squared Error between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth_yes$beta), mses$yes, col = 2, pch = 16)
lines(lowess(mses$no ~ rowMeans(res_truth_no$beta)))
lines(lowess(mses$yes ~ rowMeans(res_truth_yes$beta)), col = 2)
dim(norm)
head(refmat)
svg("results/concordance with truth - pancreas.svg", width = 6, height = 4)
par(mfrow = c(1,2))
par(mar = c(5,6,2,1))
plot(rowMeans(res_truth_no$beta)[rownames(cors)], cors$no, pch = 16,
ylab = "Correlation between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth_yes$beta)[rownames(cors)], cors$yes, col = 2, pch = 16)
lines(lowess(cors$no ~ rowMeans(res_truth_no$beta)[rownames(cors)]))
lines(lowess(cors$yes ~ rowMeans(res_truth_yes$beta)[rownames(cors)]), col = 2)
legend("bottomright", pch = 16, col = c(1,2), legend = c("Outliers retained", "Outliers removed"), cex = 0.8)
plot(rowMeans(res_truth_no$beta), mses$no, pch = 16,
ylab = "Mean Squared Error between results from\nperturbed and unperturbed data",
xlab = "Mean cell type abundance")
points(rowMeans(res_truth_yes$beta), mses$yes, col = 2, pch = 16)
lines(lowess(mses$no ~ rowMeans(res_truth_no$beta)))
lines(lowess(mses$yes ~ rowMeans(res_truth_yes$beta)), col = 2)
dev.off()
source("~/SpatialDecon-manuscript-analyses/fig s___ - outlier removal in kidney and pancreas/study outlier removal in kidney.R")
